name: Master CICD Pipeline

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "which path to run (nonprod or prod)"
        required: true
        default: nonprod
        type: choice
        options:
          - nonprod
          - prod

  push:
    branches:
      - main
      - aks-2

permissions:
  id-token: write
  contents: write

jobs:
  aks-cicd:
    uses: JMA-Apps/core-plus-workflows/.github/workflows/aks-cicd.yml@v1 
    with:
      # Application metadata
      applicationName: "myapp"
      applicationRole: "api" 
      productName: "myproduct"
      applicationId: ""

      # Mode controls nonprod vs prod path inside CD
      environment: ${{ github.event.inputs.mode }}

      # Build configuration
      dockerfilePath: Dockerfile
      buildArgs: ""
      dockerBuildSecret: "dummy-nuget-api-key"

      # Image version (affects Docker tag)
      version: "1.0.0"

      # Helm chart metadata
      chart: "batchjob"
      chartVersion: "1.2.3"
      createNamespace: false
      debug: false
      registryNonProd: "crjmanonprodakseastusa"
      registryProd: "crjmaprodakseastusa"

      # Skip flags
      skipDev: false
      skipStg: false
      skipUat: true
      skipProd: true
      
      # Azure Subscription IDs
      DEV_SUB_ID:  264f7990-fdfc-4ca8-89ce-efc3cd8f1903
      STG_SUB_ID:  264f7990-fdfc-4ca8-89ce-efc3cd8f1903
      UAT_SUB_ID:  264f7990-fdfc-4ca8-89ce-efc3cd8f1903
      PROD_SUB_ID: fcdf2387-8669-4bb8-8b65-32109c5f91f2

      # Azure Client IDs 
      DEV_CLIENT_ID:  "570edd59-52b8-430f-b361-0b7ad07ebcd1"
      STG_CLIENT_ID:  "1fba55d1-f181-4cc0-b26e-8d45fe516d91"
      UAT_CLIENT_ID:  "570edd59-52b8-430f-b361-0b7ad07ebcd1"
      PROD_CLIENT_ID: "435b2f5d-c1c7-44d7-89a4-bd2a76a16847"

    secrets: inherit
    

==================
name: aks-cicd

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true

      applicationName:
        type: string
        required: true
      applicationRole:
        type: string
        required: true
      productName:
        type: string
        required: true
      applicationId:
        type: string
        required: false
        default: ""

      dockerfilePath:
        type: string
        required: false
        default: Dockerfile
      buildArgs:
        type: string
        required: false
        default: ""
      dockerBuildSecret:
        type: string
        required: false
        default: ""

      chart:
        type: string
        required: true
      chartVersion:
        type: string
        required: false
        default: ""

      version:
        type: string
        required: true
        default: "latest"

      createNamespace:
        type: boolean
        required: false
        default: false

      registryNonProd:
        type: string
        required: true
        default:  "crjmanonprodakseastusa"
      registryProd:
        type: string
        required: true
        default:  "crjmaprodakseastusa"

      skipScan:
        type: boolean
        required: false
        default: false

      debug:
        type: boolean
        required: false
        default: false

      DEV_CLIENT_ID:
        type: string
        required: true
        default:  "570edd59-52b8-430f-b361-0b7ad07ebcd1"
      STG_CLIENT_ID:
        type: string
        required: true
        default:  "1fba55d1-f181-4cc0-b26e-8d45fe516d91"
      UAT_CLIENT_ID:
        type: string
        required: true
        default:   "570edd59-52b8-430f-b361-0b7ad07ebcd1"
      PROD_CLIENT_ID:
        type: string
        required: true
        default:  "435b2f5d-c1c7-44d7-89a4-bd2a76a16847"

      DEV_SUB_ID:
        type: string
        required: true
      STG_SUB_ID:
        type: string
        required: true
      UAT_SUB_ID:
        type: string
        required: true
      PROD_SUB_ID:
        type: string
        required: true

      # ------------------------------
      # ✅ Added missing skip inputs
      # ------------------------------
      skipDev:
        type: boolean
        required: false
        default: false
      skipStg:
        type: boolean
        required: false
        default: false
      skipUat:
        type: boolean
        required: false
        default: true
      skipProd:
        type: boolean
        required: false
        default: true

    secrets:
      AUTOMATION_TOKEN:
        required: true

permissions:
  contents: write
  id-token: write

jobs:

  ci:
    uses: ./.github/workflows/aks-ci.yml
    with:
      environment: ${{ inputs.environment }}
      applicationName: ${{ inputs.applicationName }}
      applicationRole: ${{ inputs.applicationRole }}
      applicationId: ${{ inputs.applicationId }}
      dockerfilePath: ${{ inputs.dockerfilePath }}
      buildArgs: ${{ inputs.buildArgs }}
      dockerBuildSecret: ${{ inputs.dockerBuildSecret }}
      version: ${{ inputs.version }}
      registryNonProd: ${{ inputs.registryNonProd }}
    secrets:
      AUTOMATION_TOKEN: ${{ secrets.AUTOMATION_TOKEN }}

  cd:
    needs: ci
    uses: ./.github/workflows/aks-cd.yml
    with:
      artifactName: ${{ needs.ci.outputs.ARTIFACT_NAME }}
      applicationName: ${{ inputs.applicationName }}
      applicationRole: ${{ inputs.applicationRole }}
      productName: ${{ inputs.productName }}
      applicationId: ${{ inputs.applicationId }}
      chart: ${{ inputs.chart }}
      chartVersion: ${{ inputs.chartVersion }}
      version: ${{ inputs.version }}
      createNamespace: ${{ inputs.createNamespace }}
      debug: ${{ inputs.debug }}
      skipScan: ${{ inputs.skipScan }}
      registryNonProd: ${{ inputs.registryNonProd }}
      registryProd: ${{ inputs.registryProd }}
      DEV_CLIENT_ID: ${{ inputs.DEV_CLIENT_ID }}
      STG_CLIENT_ID: ${{ inputs.STG_CLIENT_ID }}
      UAT_CLIENT_ID: ${{ inputs.UAT_CLIENT_ID }}
      PROD_CLIENT_ID: ${{ inputs.PROD_CLIENT_ID }}
      DEV_SUB_ID: ${{ inputs.DEV_SUB_ID }}
      STG_SUB_ID: ${{ inputs.STG_SUB_ID }}
      UAT_SUB_ID: ${{ inputs.UAT_SUB_ID }}
      PROD_SUB_ID: ${{ inputs.PROD_SUB_ID }}
      skipDev: ${{ inputs.skipDev }}
      skipStg: ${{ inputs.skipStg }}
      skipUat: ${{ inputs.skipUat }}
      skipProd: ${{ inputs.skipProd }}
    secrets:
      AUTOMATION_TOKEN: ${{ secrets.AUTOMATION_TOKEN }}

=========================================

name: aks-ci

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true

      applicationName:
        type: string
        required: true
      applicationRole:
        type: string
        required: true
      applicationId:
        type: string
        required: false
        default: ""

      dockerfilePath:
        type: string
        required: false
        default: Dockerfile

      buildArgs:
        type: string
        required: false
        default: ""

      dockerBuildSecret:
        type: string
        required: false
        default: ""

      version:
        type: string
        required: true
        default: "latest"

      registryNonProd:
        type: string
        required: true
        default:  "crjmanonprodakseastusa"
    secrets:
      AUTOMATION_TOKEN:
        required: true


permissions:
  contents: write
  id-token: write

jobs:
  Build:
    runs-on: internal

    outputs:
      SHORT_SHA: ${{ steps.set_image.outputs.SHORT_SHA }}
      TARFILE: ${{ steps.save.outputs.TAR }}
      ARTIFACT_NAME: ${{ steps.upload.outputs.name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Enable BuildKit
        run: echo "DOCKER_BUILDKIT=1" >> $GITHUB_ENV

      - name: Set image variables
        id: set_image
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          echo "SHORT_SHA=${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Build Docker image (local)
        id: build
        run: |
          SHORT_SHA=${{ steps.set_image.outputs.SHORT_SHA }}
          IMAGE="${{ inputs.registryNonProd }}.azurecr.io/${{ inputs.applicationName }}-${{ inputs.applicationRole }}:${{ inputs.version }}-${SHORT_SHA}"

          BUILD_ARGS=""
          if [ -n "${{ inputs.buildArgs }}" ]; then
            BUILD_ARGS="--build-arg ${{ inputs.buildArgs }}"
          fi

          SECRET_ARG=""
          if [ -n "${{ inputs.dockerBuildSecret }}" ]; then
            export NUGET_API_KEY="${{ inputs.dockerBuildSecret }}"
            SECRET_ARG="--secret id=NUGET_API_KEY,env=NUGET_API_KEY"
          fi

          docker build \
            -f ${{ inputs.dockerfilePath }} \
            $BUILD_ARGS \
            $SECRET_ARG \
            -t "$IMAGE" .

          echo "IMAGE=${IMAGE}" >> $GITHUB_OUTPUT

      - name: Save Docker image to tar
        id: save
        run: |
          TAR="${{ inputs.applicationName }}-${{ inputs.applicationRole }}-${{ inputs.version }}-${{ inputs.environment }}.tar"
          docker save -o "$TAR" "${{ steps.build.outputs.IMAGE }}"
          echo "TAR=$TAR" >> $GITHUB_OUTPUT

      - name: Upload docker artifact
        id: upload
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ inputs.applicationName }}-${{ steps.set_image.outputs.SHORT_SHA }}
          path: ${{ steps.save.outputs.TAR }}


===============================

name: aks-cd

on:
  workflow_call:
    inputs:
      artifactName:
        type: string
        required: true
      applicationName:
        type: string
        required: true
      applicationRole:
        type: string
        required: true
      productName:
        type: string
        required: true
      applicationId:
        type: string
        required: false
        default: ""
      chart:
        type: string
        required: true
      version:
        type: string
        required: true
      chartVersion:
        type: string
        required: false
        default: ""
      createNamespace:
        type: boolean
        required: false
        default: false
      debug:
        type: boolean
        required: false
        default: false
      skipScan:
        type: boolean
        required: false
        default: false
      registryNonProd:
        type: string
        required: true
        default:  "crjmanonprodakseastusa"
      registryProd:
        type: string
        required: true
        default:  "crjmaprodakseastusa" 
      DEV_CLIENT_ID:
        type: string
        required: true
        default:  "570edd59-52b8-430f-b361-0b7ad07ebcd1"
      STG_CLIENT_ID:
        type: string
        required: true
        default:  "1fba55d1-f181-4cc0-b26e-8d45fe516d91"
      UAT_CLIENT_ID:
        type: string
        required: true
        default:   "570edd59-52b8-430f-b361-0b7ad07ebcd1"
      PROD_CLIENT_ID:
        type: string
        required: true
        default:  "435b2f5d-c1c7-44d7-89a4-bd2a76a16847"
        
      DEV_SUB_ID:
        type: string
        required: true
      STG_SUB_ID:
        type: string
        required: true
      UAT_SUB_ID:
        type: string
        required: true
      PROD_SUB_ID:
        type: string
        required: true
      skipDev:
        type: boolean
        required: false
        default: false
      skipStg:
        type: boolean
        required: false
        default: false
      skipUat:
        type: boolean
        required: false
        default: false
      skipProd:
        type: boolean
        required: false
        default: false
    secrets:
      AUTOMATION_TOKEN:
        required: true

permissions:
  contents: write
  id-token: write


# NONPROD: publish


jobs:
  publish-nonprod:
    name: Publish-nonprod
    runs-on: internal
    if: ${{ !inputs.skipDev || !inputs.skipStg || !inputs.skipUat }}
    environment: dev
    env:
      CHART_FOLDER: helm/${{ inputs.chart }}
      DEBUG_FLAG: ${{ inputs.debug && '--debug' || '' }}
      AKS_CLUSTER_NAME: aks-jma-nonprod-eastus-a
      AKS_RESOURCE_GROUP: rg-jma-nonprod-aksinfra-eastus-a
      HELM_DRIVER: configmap
      REGISTRY: ${{ inputs.registryNonProd }}
      AKS_SUBSCRIPTION: ${{ inputs.DEV_SUB_ID }}
      AKS_CLIENT_ID: ${{ inputs.DEV_CLIENT_ID }}
    outputs:
      published-image: ${{ steps.publish.outputs.PUBLISHED_IMAGE }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Docker artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifactName }}
          path: ./artifact-temp

      - name: Load Docker image from artifact
        id: load
        run: |
          set -euo pipefail
          TARFILE=$(find ./artifact-temp -name "*.tar" | head -n1)
          if [ -z "$TARFILE" ]; then
            echo "No Docker artifact found!"
            exit 1
          fi
          docker load -i "$TARFILE"

      - name: Azure login (OIDC) for AKS/ACR
        uses: azure/login@v2
        with:
          client-id: ${{ env.AKS_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AKS_SUBSCRIPTION }}

      - name: Publish image to NonProd ACR
        id: publish
        run: |
          set -euo pipefail
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          IMAGE_TAG="${{ inputs.version }}-${SHORT_SHA}"
          SRC=$(docker images --format '{{.Repository}}:{{.Tag}}' | head -n1)
          if [ -z "$SRC" ]; then
            echo "ERROR: No docker image loaded."
            exit 1
          fi
          TARGET="${{ env.REGISTRY }}.azurecr.io/${{ inputs.applicationName }}-${{ inputs.applicationRole }}:${IMAGE_TAG}"
          echo "Tagging and pushing image → $TARGET"
          az acr login --name ${{ env.REGISTRY }}
          docker tag "$SRC" "$TARGET"
          docker push "$TARGET"
          echo "PUBLISHED_IMAGE=$TARGET" >> $GITHUB_OUTPUT

      - name: Docker Scout Scan
        if: ${{ !inputs.skipScan }}
        uses: JM-Actions/containerimage-scan-dockerscout@v1
        with:
          image: ${{ steps.publish.outputs.PUBLISHED_IMAGE }}
          azure-client-id: ${{ env.AKS_CLIENT_ID }}
          azure-aks-subscription-id: ${{ env.AKS_SUBSCRIPTION }}
          github-token: ${{ secrets.AUTOMATION_TOKEN }}

  deploy-nonprod:
    name: Deploy-${{ matrix.environment }}
    runs-on: internal
    needs: publish-nonprod
    environment: ${{ matrix.environment }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - environment: dev
            skip: ${{ inputs.skipDev }}
          - environment: stg
            skip: ${{ inputs.skipStg }}
          - environment: uat
            skip: ${{ inputs.skipUat }}
    
    env:
      CHART_FOLDER: helm/${{ inputs.chart }}
      DEBUG_FLAG: ${{ inputs.debug && '--debug' || '' }}
      AKS_CLUSTER_NAME: aks-jma-nonprod-eastus-a
      AKS_RESOURCE_GROUP: rg-jma-nonprod-aksinfra-eastus-a
      HELM_DRIVER: configmap
      REGISTRY: ${{ inputs.registryNonProd }}
      AKS_CLIENT_ID: ${{ matrix.environment == 'dev' && inputs.DEV_CLIENT_ID || matrix.environment == 'stg' && inputs.STG_CLIENT_ID || inputs.UAT_CLIENT_ID }}
      AKS_SUBSCRIPTION: ${{ matrix.environment == 'dev' && inputs.DEV_SUB_ID || matrix.environment == 'stg' && inputs.STG_SUB_ID || inputs.UAT_SUB_ID }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC) for AKS/ACR
        uses: azure/login@v2
        with:
          client-id: ${{ env.AKS_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AKS_SUBSCRIPTION }}

      - name: Install kubectl & kubelogin (with retries)
        run: |
          set -e
          for i in {1..3}; do
            echo "Installing kubectl/kubelogin… attempt $i"
            if az aks install-cli; then break; fi
            if [ $i -eq 3 ]; then exit 1; fi
            sleep 5
          done

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}
          use-kubelogin: true

      - name: Verify cluster access
        run: |
          set -euo pipefail
          kubectl version --client
          kubectl get ns

      - name: Deploy to ${{ matrix.environment }} namespace
        env:
          IMAGE: ${{ needs.publish-nonprod.outputs.published-image }}
        run: |
          set -euo pipefail
          ENV="${{ matrix.environment }}"
          ns="ns-jma-${ENV}-${{ inputs.productName }}"
          if [ -n "${{ inputs.applicationId }}" ]; then
            ns="${ns}-${{ inputs.applicationId }}"
          fi
          echo "Deploying → Namespace: $ns"
          if [ "${{ inputs.createNamespace }}" = "true" ]; then
            kubectl create ns "$ns" --dry-run=client -o yaml | kubectl apply -f -
          fi
          VALUES_FILE="${CHART_FOLDER}/${ENV}.yaml"
          if [ ! -f "$VALUES_FILE" ]; then
            echo "Missing Helm values file: $VALUES_FILE"
            exit 1
          fi
          VERSION_FLAG=""
          if [ -n "${{ inputs.chartVersion }}" ]; then
            VERSION_FLAG="--version ${{ inputs.chartVersion }}"
          fi
          RELEASE="nonprod-${{ inputs.applicationName }}-${{ inputs.applicationRole }}"
          if [ -n "${{ inputs.applicationId }}" ]; then
            RELEASE="${RELEASE}-${{ inputs.applicationId }}"
          fi
          helm upgrade "$RELEASE" "$CHART_FOLDER" \
            --install \
            --namespace "$ns" \
            --values "$VALUES_FILE" \
            $VERSION_FLAG \
            --set image.full="$IMAGE" \
            ${{ env.DEBUG_FLAG }}
          echo "Deployment to $ns completed."


# PROD: 


  publish-prod:
    name: Publish-prod
    runs-on: internal
    if: ${{ !inputs.skipProd }}
    environment: prod
    env:
      CHART_FOLDER: helm/${{ inputs.chart }}
      DEBUG_FLAG: ${{ inputs.debug && '--debug' || '' }}
      AKS_CLUSTER_NAME: aks-jma-prod-eastus-a
      AKS_RESOURCE_GROUP: rg-jma-prod-aksinfra-eastus-a
      HELM_DRIVER: configmap
      REGISTRY: ${{ inputs.registryProd }}
      AKS_SUBSCRIPTION: ${{ inputs.PROD_SUB_ID }}
      AKS_CLIENT_ID: ${{ inputs.PROD_CLIENT_ID }}
    outputs:
      published-image: ${{ steps.publish.outputs.PUBLISHED_IMAGE }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Docker artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifactName }}
          path: ./artifact-temp

      - name: Load Docker image from artifact
        id: load
        run: |
          set -euo pipefail
          TARFILE=$(find ./artifact-temp -name "*.tar" | head -n1)
          if [ -z "$TARFILE" ]; then
            echo "No Docker artifact found!"
            exit 1
          fi
          docker load -i "$TARFILE"

      - name: Azure login (OIDC) for AKS/ACR
        uses: azure/login@v2
        with:
          client-id: ${{ env.AKS_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AKS_SUBSCRIPTION }}

      - name: Publish image to Prod ACR
        id: publish
        run: |
          set -euo pipefail
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-8)
          IMAGE_TAG="${{ inputs.version }}-${SHORT_SHA}"
          SRC=$(docker images --format '{{.Repository}}:{{.Tag}}' | head -n1)
          if [ -z "$SRC" ]; then
            echo "ERROR: No docker image loaded."
            exit 1
          fi
          TARGET="${{ env.REGISTRY }}.azurecr.io/${{ inputs.applicationName }}-${{ inputs.applicationRole }}:${IMAGE_TAG}"
          echo "Tagging and pushing image → $TARGET"
          az acr login --name ${{ env.REGISTRY }}
          docker tag "$SRC" "$TARGET"
          docker push "$TARGET"
          echo "PUBLISHED_IMAGE=$TARGET" >> $GITHUB_OUTPUT

      - name: Docker Scout Scan
        if: ${{ !inputs.skipScan }}
        uses: JM-Actions/containerimage-scan-dockerscout@v1
        with:
          image: ${{ steps.publish.outputs.PUBLISHED_IMAGE }}
          azure-client-id: ${{ env.AKS_CLIENT_ID }}
          azure-aks-subscription-id: ${{ env.AKS_SUBSCRIPTION }}
          github-token: ${{ secrets.AUTOMATION_TOKEN }}

  deploy-prod:
    name: Deploy-prod
    runs-on: internal
    needs: publish-prod
    if: ${{ !inputs.skipProd }}
    environment: prod
    strategy:
      fail-fast: false
      matrix:
        environment: [prod]
    env:
      CHART_FOLDER: helm/${{ inputs.chart }}
      DEBUG_FLAG: ${{ inputs.debug && '--debug' || '' }}
      AKS_CLUSTER_NAME: aks-jma-prod-eastus-a
      AKS_RESOURCE_GROUP: rg-jma-prod-aksinfra-eastus-a
      HELM_DRIVER: configmap
      REGISTRY: ${{ inputs.registryProd }}
      AKS_SUBSCRIPTION: ${{ inputs.PROD_SUB_ID }}
      AKS_CLIENT_ID: ${{ inputs.PROD_CLIENT_ID }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC) for AKS/ACR
        uses: azure/login@v2
        with:
          client-id: ${{ env.AKS_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AKS_SUBSCRIPTION }}

      - name: Install kubectl & kubelogin (with retries)
        run: |
          set -e
          for i in {1..3}; do
            echo "Installing kubectl/kubelogin… attempt $i"
            if az aks install-cli; then break; fi
            if [ $i -eq 3 ]; then exit 1; fi
            sleep 5
          done

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}
          use-kubelogin: true

      - name: Verify cluster access
        run: |
          set -euo pipefail
          kubectl version --client
          kubectl get ns

      - name: Deploy to prod namespace
        env:
          IMAGE: ${{ needs.publish-prod.outputs.published-image }}
        run: |
          set -euo pipefail
          ENV="${{ matrix.environment }}"
          ns="ns-jma-${ENV}-${{ inputs.productName }}"
          if [ -n "${{ inputs.applicationId }}" ]; then
            ns="${ns}-${{ inputs.applicationId }}"
          fi
          echo "Deploying → Namespace: $ns"
          if [ "${{ inputs.createNamespace }}" = "true" ]; then
            kubectl create ns "$ns" --dry-run=client -o yaml | kubectl apply -f -
          fi
          VALUES_FILE="${CHART_FOLDER}/${ENV}.yaml"
          if [ ! -f "$VALUES_FILE" ]; then
            echo "Missing Helm values file: $VALUES_FILE"
            exit 1
          fi
          VERSION_FLAG=""
          if [ -n "${{ inputs.chartVersion }}" ]; then
            VERSION_FLAG="--version ${{ inputs.chartVersion }}"
          fi
          RELEASE="prod-${{ inputs.applicationName }}-${{ inputs.applicationRole }}"
          if [ -n "${{ inputs.applicationId }}" ]; then
            RELEASE="${RELEASE}-${{ inputs.applicationId }}"
          fi
          helm upgrade "$RELEASE" "$CHART_FOLDER" \
            --install \
            --namespace "$ns" \
            --values "$VALUES_FILE" \
            $VERSION_FLAG \
            --set image.full="$IMAGE" \
            ${{ env.DEBUG_FLAG }}
          echo "Deployment to $ns completed."
