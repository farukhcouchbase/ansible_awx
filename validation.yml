- name: Validate and Create Couchbase Indexes 
  hosts: all
  gather_facts: no  
  vars:
    couchbase_bin_path: "/path/to/couchbase_bin"
    couchbase_admin_username: ""
    couchbase_admin_password: ""  
    index_queries: []  
    INDEX_NAME: ""
    script_path: "~/deffered_index.sh"
    duplicate_indexes: []
    some_query_output: []  
    existing_index_map: []
    query_types: []
    query_type: ""

    specific_index_list: []
    default_index_list: []
    
    deffered_index_path: "/path/to/deffered_index.sh"
    default_index_path: "/path/to/default_index.sh"

  tasks:
    - name: Identify and categorize index queries
      set_fact:
        allowed_queries: []
        allowed_queries1: []
        allowed_queries2: []
        not_allowed_queries: []
        queries_exceeding_fields: []
        query_field_mapping: []
        query_field_list: []

    - name: Extract bucket name from Couchbase index query
      set_fact:
        bucket_name: "{{ index_queries | regex_search('ON `([^`]+)`', '\\1') }}"

    - name: Print the extracted bucket name
      debug:
        msg: "The extracted bucket name is: {{ bucket_name }}"    

    - name: Extract operation type from Couchbase index query
      vars:
        query_type: "{{ index_queries | regex_search('^(CREATE|DROP|ALTER)', ignorecase=True) }}"
      debug:
        msg: >-
          {% if query_type is not none %}
            The query is of type: {{ query_type }}
          {% else %}
            The query type could not be determined.
          {% endif %}    

    - name: Run Couchbase query script
      shell: >
        {{ couchbase_bin_path }} -u {{ couchbase_admin_username }} -p {{ couchbase_admin_password }} -s "SELECT * FROM system:indexes;" > fields.json 2>&1
      
    - name: Validate syntax of index queries
      shell: "{{ couchbase_bin_path }} -u {{ couchbase_admin_username }} -p {{ couchbase_admin_password }} -s 'EXPLAIN {{ item }}'"
      with_items: "{{ index_queries }}"
      register: syntax_check
      no_log: true

    - name: Fail if any index query has syntax errors
      fail:
        msg: "Index Query contains a syntax error. Double-check the error and re-run the query."
      when: syntax_check.results | selectattr('stdout', 'search', 'syntax error') | list | length > 0 

    - name: Validate index queries
      set_fact:
        allowed_queries: "{{ allowed_queries + [item] }}"
      when:
        - "not item | regex_search('CREATE PRIMARY INDEX', ignorecase=True)"
        - "not item | regex_search('META\\(\\)\\.id', ignorecase=True)"
        - "item | regex_search('CREATE INDEX', ignorecase=True)"
        - "item | regex_search('WHERE', ignorecase=True)"
      with_items: "{{ index_queries }}"

    - name: Run cbq command and save output to fields.json
      shell: /opt/couchbase/bin/cbq -u Admin -p redhat -s "SELECT * FROM system:indexes;" > fields.json 2>&1
      args:
        chdir: /home/ubuntu

    - name: Remove first 5 lines and create new_fields.json
      shell: tail -n +6 fields.json > new_fields.json
      args: 
        chdir: /home/ubuntu

    - name: Convert JSON to plain text using jq
      shell: jq -r '.[] | @text' new_fields.json > plain1.txt
      args:
        chdir: /home/ubuntu

    - name: Run extract2.py and redirect output to fields1.txt
      shell: python3 extract2.py > fields1.txt
      args:
        chdir: /home/ubuntu
        
    - name: Read file /home/ubuntu/fields1.txt
      slurp:
        src: /home/ubuntu/fields1.txt
      register: file_content

    - name: Set decoded file content as variable
      set_fact:
        decoded_indexes: "{{ file_content.content | b64decode }}"

    ##################################################################
    # QUERY TYPE IDENTIFICATION (UPDATED)
    ##################################################################
    
    # 1. Ensure index_queries is a list
    - name: Ensure index_queries is a list
      set_fact:
        index_queries_list: >-
          {{
            (index_queries | default(''))
            | regex_replace(';$','')                       
            | regex_findall('[^\r\n]+')                   
            | map('trim')                                   
            | reject('equalto','')                         
            | list
          }}

    # 2. Initialize query_type_flags as empty list (safety)
    - name: Initialize query_type_flags as empty list
      set_fact:
        query_type_flags: []
 
    # - name: Determine query type for each index query and set flags
    #   set_fact:
    #     query_type_flags: >-
    #       {{
    #         (index_queries_list | default([]))
    #         | map('regex_search', '^CREATE INDEX .*`[^`]+`(?:\\.`[^`]+`\\.`[^`]+`)?', ignorecase=True)
    #         | map('ternary', 'specific', 'default')
    #         | list 
    #       }}
    
    - name: Determine query type for each index query and set flags
      set_fact:
        query_type_flags: >-
          {{
            (index_queries_list | default([]))
            | map('regex_search', '^CREATE INDEX .*`[^`]+`\.`[^`]+`\.`[^`]+`', ignorecase=True)
            | map('ternary', 'specific', 'default')
            | list
          }}

    # 4. Debug - Query type flags
    - name: Debug - Query type flags
      debug:
        msg: "Query {{ item_index }} is '{{ query_type_flags[item_index] }}'"
      loop: "{{ range(0, index_queries_list | length) | list }}"
      loop_control:
        loop_var: item_index

    # 5. Initialize default index list
    - name: Initialize default index list
      set_fact:
        default_index_list: "{{ default_index_list | default([]) + [ index_queries_list[item_index] ] }}"
      loop: "{{ range(0, index_queries_list | length) | list }}"
      loop_control:
        loop_var: item_index
      when: query_type_flags[item_index] == 'default'

    # 6. Initialize specific index list
    - name: Initialize specific index list
      set_fact:
        specific_index_list: "{{ specific_index_list | default([]) + [ index_queries_list[item_index] ] }}"
      loop: "{{ range(0, index_queries_list | length) | list }}"
      loop_control:
        loop_var: item_index
      when: query_type_flags[item_index] == 'specific'

    # 7. Optional: Debug the final lists
    - name: Debug - Final index lists
      debug:
        msg:
          default_indexes: "{{ default_index_list | default([]) }}"
          specific_indexes: "{{ specific_index_list | default([]) }}"

    - name: Set execution mode for index flow
      set_fact:
        is_default_query: "{{ (default_index_list | length > 0) and (specific_index_list | length == 0) }}"
        is_specific_query: "{{ (specific_index_list | length > 0) and (default_index_list | length == 0) }}"      

    ##################################################################
    # DEFAULT vs SPECIFIC INDEX FLOW EXECUTION PER QUERY
    ##################################################################
    

    ##################################################################
    # DEFAULT INDEX FLOW
    ##################################################################
    - name: DEFAULT INDEX FLOW - Execute only for default queries
      block:

        - name: Initialize default index lists
          set_fact:
            default_all_indexes: []
            default_current_index: {}

        - name: Parse decoded indexes line by line for default
          set_fact:
            default_current_index: >-
              {{
                default_current_index | combine({
                  'name': (item.split(':',1)[1] | trim) if item.startswith('NAME') else default_current_index.get('name', ''),
                  'bucket': (item.split(':',1)[1] | trim) if item.startswith('Bucket ID') else default_current_index.get('bucket', 'travel-sample'),
                  'scope': (item.split(':',1)[1] | trim) if item.startswith('Scope ID') else default_current_index.get('scope', 'default'),
                  'collection': (item.split(':',1)[1] | trim) if item.startswith('Keyspace ID') else default_current_index.get('collection', 'default'),
                  'fields': (item.split(':',1)[1] | trim) if item.startswith('Index Key') else default_current_index.get('fields', '')
                })
              }}
          loop: "{{ decoded_indexes.split('\n') }}"
          when: item | trim != ''

        - name: Debug - Current default index after parsing
          debug:
            var: default_current_index

        - name: Append parsed default index
          set_fact:
            default_all_indexes: "{{ default_all_indexes + [ default_current_index | combine({
                  'name': default_current_index.name | default('unnamed_index'),
                  'bucket': default_current_index.bucket | default('travel-sample'),
                  'scope': default_current_index.scope | default('default'),
                  'collection': default_current_index.collection | default('default'),
                  'fields': default_current_index.fields | default('')
              }) ] }}"

        - name: Reset default_current_index
          set_fact:
            default_current_index: {}

        - name: Convert default indexes into index_meta format
          set_fact:
            default_index_meta:
              name: "{{ default_all_indexes | map(attribute='name') | list }}"
              bucket: "{{ default_all_indexes | map(attribute='bucket') | list }}"
              scope: "{{ default_all_indexes | map(attribute='scope') | list }}"
              collection: "{{ default_all_indexes | map(attribute='collection') | list }}"
              fields: "{{ default_all_indexes | map(attribute='fields') | list }}"

        - name: Debug - Default index_meta
          debug:
            var: default_index_meta

        - name: Extract default query metadata
          set_fact:
            default_query_meta:
              name: "{{ index_queries | regex_search('(?i)CREATE\\s+INDEX\\s+([`\\w]+)', '\\1') | default('unnamed_index') }}"
              bucket: "{{ index_queries | regex_search('ON `([^`]+)`\\.', '\\1') | default('travel-sample') }}"
              scope: "{{ index_queries | regex_search('ON `[^`]+`\\.`([^`]+)`\\.', '\\1') | default('default') }}"
              collection: "{{ index_queries | regex_search('ON `[^`]+`\\.`[^`]+`\\.`([^`]+)`', '\\1') | default('default') }}"
              fields: "{{ index_queries | regex_search('\\((.*?)\\)\\s*WHERE', '\\1') | default('') }}"

        - name: Debug - Extracted default query metadata
          debug:
            var: default_query_meta

        - name: Normalize existing default index fields as list
          set_fact:
            default_all_indexes_normalized: >-
              {%- set result = [] -%}
              {%- for idx in default_all_indexes -%}
              {%-   set fields_clean = (
                      (idx.fields | default(''))
                      | regex_replace('^\\[|\\]$', '')        
                      | regex_replace("'", '')               
                      | regex_replace('`', '')                
                      | regex_replace('[()]', '')             
                      | regex_replace('\\s+', ' ')            
                      | lower
                    ).split(',')
                    | map('trim')
                    | select('ne','')
                    | list
              -%}
              {%-   set _ = result.append(idx | combine({
                      'normalized_fields_list': fields_clean,
                      'bucket': idx.bucket | default('travel-sample') | string,
                      'scope': idx.scope | default('default') | string,
                      'collection': idx.collection | default('default') | string
                    })) -%}
              {%- endfor -%}
              {{ result }}

        - name: Normalize new query fields as list (default)
          set_fact:
            default_query_normalized_fields_list: >-
              {%- set result = [] -%}
              {%- set raw_fields = default_query_meta.fields | default('') -%}
              {%- if raw_fields != '' -%}
                {%- set fields_clean = (
                        raw_fields
                        | regex_replace('^\\[|\\]$', '')     
                        | regex_replace("'", '')              
                        | regex_replace('`', '')               
                        | regex_replace('[()]', '')              
                        | regex_replace('\\s+', ' ')          
                        | lower
                      ).split(',')
                      | map('trim')
                      | select('ne','')
                      | list
                -%}
                {%- set _ = result.extend(fields_clean) -%}
              {%- endif -%}
              {{ result }}

        - name: Fail if any existing default index conflicts with new query
          fail:
            msg: >-
              ⚠️ Index conflict detected! Existing index "{{ item.name }}" in
              bucket "{{ item.bucket }}", scope "{{ item.scope }}",
              collection "{{ item.collection }}" has the same fields as new index
              "{{ default_query_meta.name }}" but different name.
          loop: "{{ default_all_indexes_normalized }}"
          loop_control:
            loop_var: item
          when: >
            (item.normalized_fields_list | sort | list) == (default_query_normalized_fields_list | sort | list)
            and item.name | lower != default_query_meta.name | lower
            and (item.bucket | lower) == (default_query_meta.bucket | lower)
            and (item.scope | lower) == (default_query_meta.scope | lower)
            and (item.collection | lower) == (default_query_meta.collection | lower)

        - name: Allow execution if default query is safe
          debug:
            msg: "✅ Default index is allowed. Either name matches or location is different."
          when: >
            default_query_meta.name in default_index_meta.name or
            default_query_meta.bucket not in default_index_meta.bucket or
            default_query_meta.scope not in default_index_meta.scope or
            default_query_meta.collection not in default_index_meta.collection

      when: is_default_query

    ##################################################################
    # SPECIFIC INDEX FLOW
    ##################################################################
    - name: SPECIFIC INDEX FLOW - Execute only for specific queries
      block:

        - name: Initialize specific index lists
          set_fact:
            specific_all_indexes: []
            specific_current_index: {}

        - name: Parse decoded indexes for specific query
          set_fact:
            specific_current_index: >-
              {{
                specific_current_index | combine({
                  'name': (item.split(':',1)[1] | trim) if item.startswith('NAME') else specific_current_index.get('name', ''),
                  'bucket': (item.split(':',1)[1] | trim) if item.startswith('Bucket ID') else specific_current_index.get('bucket', ''),
                  'scope': (item.split(':',1)[1] | trim) if item.startswith('Scope ID') else specific_current_index.get('scope', ''),
                  'collection': (item.split(':',1)[1] | trim) if item.startswith('Keyspace ID') else specific_current_index.get('collection', ''),
                  'fields': (item.split(':',1)[1] | trim) if item.startswith('Index Key') else specific_current_index.get('fields', '')
                })
              }}
          loop: "{{ decoded_indexes.split('\n') }}"
          when: item|trim != ''

        - name: Append parsed specific index
          set_fact:
            specific_all_indexes: "{{ specific_all_indexes + [ specific_current_index | combine({
                  'name': specific_current_index.name | default('unnamed_index'),
                  'bucket': specific_current_index.bucket | default('unknown_bucket'),
                  'scope': specific_current_index.scope | default('default_scope'),
                  'collection': specific_current_index.collection | default('default_collection'),
                  'fields': specific_current_index.fields | default('')
              }) ] }}"

        - name: Reset specific_current_index
          set_fact:
            specific_current_index: {}

        - name: Convert specific indexes into index_meta format
          set_fact:
            specific_index_meta:
              name: "{{ specific_all_indexes | map(attribute='name') | list }}"
              bucket: "{{ specific_all_indexes | map(attribute='bucket') | list }}"
              scope: "{{ specific_all_indexes | map(attribute='scope') | list }}"
              collection: "{{ specific_all_indexes | map(attribute='collection') | list }}"
              fields: "{{ specific_all_indexes | map(attribute='fields') | list }}"

        - name: Debug - specific index_meta
          debug:
            var: specific_index_meta

        - name: Extract specific query metadata
          set_fact:
            specific_query_meta:
              name: "{{ index_queries | regex_search('(?i)CREATE\\s+INDEX\\s+([`\\w]+)', '\\1') | default('') }}"
              bucket: "{{ index_queries | regex_search('ON `([^`]+)`\\.', '\\1') | default('') }}"
              scope: "{{ index_queries | regex_search('ON `[^`]+`\\.`([^`]+)`\\.', '\\1') | default('') }}"
              collection: "{{ index_queries | regex_search('ON `[^`]+`\\.`[^`]+`\\.`([^`]+)`', '\\1') | default('') }}"
              fields: "{{ index_queries | regex_search('\\((.*?)\\)\\s*WHERE', '\\1') | default('') }}"

        - name: Debug - Extracted specific query metadata
          debug:
            var: specific_query_meta

        - name: Normalize existing specific index fields as list
          set_fact:
            specific_all_indexes_normalized: >-
              {%- set result = [] -%}
              {%- for idx in specific_all_indexes -%}
              {%-   set fields_clean = (
                      (idx.fields | default(''))
                      | regex_replace('^\\[|\\]$', '')        
                      | regex_replace("'", '')               
                      | regex_replace('`', '')                
                      | regex_replace('[()]', '')             
                      | regex_replace('\\s+', ' ')            
                      | lower
                    ).split(',')
                    | map('trim')
                    | select('ne','')
                    | list
              -%}
              {%-   set _ = result.append(idx | combine({'normalized_fields_list': fields_clean})) -%}
              {%- endfor -%}
              {{ result }}

        - name: Normalize new query fields as list (specific)
          set_fact:
            specific_query_normalized_fields_list: >-
              {%- set result = [] -%}
              {%- set raw_fields = specific_query_meta.fields | default('') -%}
              {%- if raw_fields != '' -%}
                {%- set fields_clean = (
                        raw_fields
                        | regex_replace('^\\[|\\]$', '')     
                        | regex_replace("'", '')              
                        | regex_replace('`', '')               
                        | regex_replace('[()]', '')              
                        | regex_replace('\\s+', ' ')          
                        | lower
                      ).split(',')
                      | map('trim')
                      | select('ne','')
                      | list
                -%}
                {%- set _ = result.extend(fields_clean) -%}
              {%- endif -%}
              {{ result }}

        - name: Fail if any existing specific index conflicts with new query
          fail:
            msg: >-
              ⚠️ Index conflict detected! Existing index "{{ item.name }}" in
              bucket "{{ item.bucket }}", scope "{{ item.scope }}",
              collection "{{ item.collection }}" has the same fields as new index
              "{{ specific_query_meta.name }}" but different name.
          loop: "{{ specific_all_indexes_normalized }}"
          loop_control:
            loop_var: item
          when: >
            (item.normalized_fields_list | sort | list) == (specific_query_normalized_fields_list | sort | list)
            and item.name | lower != specific_query_meta.name | lower
            and item.bucket | lower == specific_query_meta.bucket | lower
            and item.scope | lower == specific_query_meta.scope | lower
            and item.collection | lower == specific_query_meta.collection | lower

        - name: Allow execution if specific query is safe
          debug:
            msg: "✅ Specific index is allowed. Either name matches or location is different."
          when: >
            specific_query_meta.name in specific_index_meta.name or
            specific_query_meta.bucket not in specific_index_meta.bucket or
            specific_query_meta.scope not in specific_index_meta.scope or
            specific_query_meta.collection not in specific_index_meta.collection

      when: not is_default_query

    ##################################################################
    # NEUTRAL VALIDATIONS & EXECUTION
    ##################################################################

        - name: Identify queries exceeding field limits
          set_fact:
            query_field_mapping: "{{ query_field_mapping | default({}) | combine({item: (item | regex_replace('.*ON\\s*[^()]+\\(([^)]+)\\).*', '\\1'))}) }}"
          with_items: "{{ index_queries }}"
          when:
            - "item is search('CREATE INDEX')"
            - "item is search('ON\\s*[^()]+\\(([^)]+)\\)')"

        - name: Convert field list to an array using split
          vars:
            cleaned_fields: "{{ item.value | replace('`', '') | regex_replace('\\s+', '') }}"
          set_fact:
            query_field_list: "{{ query_field_list | default({}) | combine({ item.key: cleaned_fields.split(',') }) }}"
          with_dict: "{{ query_field_mapping }}"

        - name: Identify queries exceeding 6 fields
          set_fact:
            queries_exceeding_fields: "{{ queries_exceeding_fields | default([]) + [item.key] }}"
          with_dict: "{{ query_field_list }}"
          when: "query_field_list[item.key] | length > 6"

        - name: Display warning for queries exceeding 6 fields
          debug:
            msg: "You are exceeding the limit of 6 fields in query '{{ item.key }}'. Please contact the admin."
          with_dict: "{{ query_field_list }}"
          when: "query_field_list[item.key] | length > 6"  

        - name: Debug - Queries exceeding field limits
          debug:
            msg: "Query exceeds field limit: {{ item }}"
          with_items: "{{ queries_exceeding_fields }}"

        - name: Stop execution if any query exceeds allowed field count
          fail:
            msg: "You are exceeding the limit of 6 fields in query .  Please contact the admin. : {{ queries_exceeding_fields }}"
          when: queries_exceeding_fields | length > 0

        - name: Identify not allowed queries
          set_fact:
            not_allowed_queries: "{{ not_allowed_queries + [item] }}"
          when:
            - "item | regex_search('CREATE PRIMARY INDEX', ignorecase=True) or not item | regex_search('WHERE', ignorecase=True)"
          with_items: "{{ index_queries }}"

        - name: Remove semicolon using regex
          set_fact:
            allowed_queries2: "{{ allowed_queries | map('regex_replace', ';\\s*$', '') | list }}"

        - name: Debug - Allowed Queries
          debug:
            msg: "\033[32mAllowed Index Query: {{ item }}\033[0m"
          with_items: "{{ allowed_queries }}"

        - name: Debug - Not Allowed Queries
          debug:
            msg: "\033[33mNot Allowed Index Query: {{ item }}\033[0m"
          with_items: "{{ not_allowed_queries }}"

        - name: Show the modified query
          debug:
            msg: "\033[34m{{ allowed_queries2 }}\033[0m"

        - name: Add WITH defer_build and num_replica options in index queries
          set_fact:
            updated_queries1: >-
              {{
                allowed_queries | map('regex_replace', 
                  '(?<=\{)(?!.*"defer_build"\\s*:\\s*true)(?=.*"num_replica"\\s*:\\s*1)', 
                  '"defer_build":true,') 
                | map('regex_replace', 
                  '(?<=\{)(?!.*"num_replica"\\s*:\\s*1)(?=.*"defer_build"\\s*:\\s*true)', 
                  '"num_replica":1,') 
                | map('regex_replace', 
                  '(?<=\{)(?!.*"defer_build"\\s*:\\s*true)(?!.*"num_replica"\\s*:\\s*1)', 
                  '"defer_build":true, "num_replica":1,')
                | list
              }}

        - name: Ensure WITH clause in index queries
          set_fact:
            updated_queries2: >-
              {{
                allowed_queries2 | map('regex_replace', 
                  'WITH\\s*\{[^}]*\}', 
                  'WITH {"defer_build": true, "num_replica": 1}') 
                | map('regex_replace', 
                  '(?i)(?!.*WITH\\s*\{.*\})$', 
                  ' WITH {"defer_build": true, "num_replica": 1}') 
                | list
              }}

        - name: Debug - Updated Index Queries (Method 1)
          debug:
            msg: "\033[32mUpdated Query: {{ item }}\033[0m"
          with_items: "{{ updated_queries1 }}"

        - name: Debug - Updated Index Queries (Method 2)
          debug:
            msg: "\033[32mUpdated Query: {{ item }}\033[0m"
          with_items: "{{ updated_queries2 }}"
      
        - name: Execute allowed index queries (Method 2)
          shell: "{{ couchbase_bin_path }} -u {{ couchbase_admin_username }} -p {{ couchbase_admin_password }} -s '{{ item }}'"
          with_items: "{{ updated_queries2 }}"
          when: updated_queries2 | length > 0
          register: query_result
          ignore_errors: no

        - name: Execute allowed index queries (Method 1)
          shell: "{{ couchbase_bin_path }} -u {{ couchbase_admin_username }} -p {{ couchbase_admin_password }} -s '{{ item }}'"
          with_items: "{{ updated_queries1 }}"
          when: updated_queries1 | length > 0
          register: query_result
          ignore_errors: no

        - name: Run deferred index script for a bucket
          command: "{{ script_path }} --bucket={{ bucket_names | join(',') }}"
          args:
            chdir: "~"  
          register: script_output

        - name: Show script output
          debug:
            var: script_output.stdout    
